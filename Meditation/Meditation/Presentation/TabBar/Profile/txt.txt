//
//  LearnCoordinator.swift
//  Unwrap
//
//  Created by Paul Hudson on 09/08/2018.
//  Copyright © 2019 Hacking with Swift.
//

import UIKit

/// Manages everything launched from the Home tab in the app.
class HomeCoordinator: Coordinator, AlertShowing {
    var splitViewController = UISplitViewController()
    var navigationController: CoordinatedNavigationController

    private static let firstRunDefaultsKey = "ShownFirstRun"

    /// True when this is the first time the app has been launched.
    var isFirstRun: Bool {
        return UserDefaults.standard.bool(forKey: HomeCoordinator.firstRunDefaultsKey) == false
    }

    init(navigationController: CoordinatedNavigationController = CoordinatedNavigationController()) {
        self.navigationController = navigationController
        navigationController.navigationBar.prefersLargeTitles = true
        navigationController.coordinator = self

        let viewController = HomeViewController.instantiate()
        viewController.tabBarItem = UITabBarItem(title: "Home", image: UIImage(bundleName: "Home"), tag: 0)
        viewController.coordinator = self

        navigationController.viewControllers = [viewController]

        if isFirstRun {
            /// If this is the first time the app is running, wait a tiny fraction of time before showing the welcome screen.
            DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                // Put the contents of showTour in here directly to avoid trying to capture `self` during an initializer.
                let viewController = WelcomeViewController.instantiate()
                viewController.presentAsAlert()

                // Mark that we've run the app at least once.
                UserDefaults.standard.set(true, forKey: HomeCoordinator.firstRunDefaultsKey)
            }
        }
    }

    /// Show the welcome screen with a short app introduction.
    func showTour() {
        let viewController = WelcomeViewController.instantiate()
        viewController.presentAsAlert()
    }

    /// Show the options to reset user progress.
    func showResetProgressOptions() {
        let alert = UIAlertController(title: "Reset data", message: nil, preferredStyle: .alert)

        let resetProgressAction = UIAlertAction(title: "Reset", style: .destructive) { _ in
            User.current.resetProgress()
        }
        let cancelAction = UIAlertAction(title: "Cancel", style: .cancel)

        alert.addAction(resetProgressAction)
        alert.addAction(cancelAction)
        navigationController.present(alert, animated: true)
    }

    /// Show the help screen.
    @objc func showHelp() {
        let viewController = HelpViewController(style: .plain)
        viewController.coordinator = self

        if UIDevice.current.userInterfaceIdiom == .pad {
            let navController = CoordinatedNavigationController(rootViewController: viewController)
            navController.modalPresentationStyle = .formSheet
            navigationController.present(navController, animated: true)
        } else {
            navigationController.pushViewController(viewController, animated: true)
        }
    }

    /// Start sharing the user's current score.
    func shareScore(from sourceRect: CGRect) {
        let image = User.current.rankImage.imageForSharing
        let text = "I'm on level \(User.current.rankNumber) in Unwrap by @twostraws. Download it here: \(Unwrap.appURL)"

        let alert = UIActivityViewController(activityItems: [text, image], applicationActivities: nil)
        alert.completionWithItemsHandler = handleScoreSharingResult

        // If we're on iPad there is nowhere sensible to anchor this from, so just center it.
        if let popOver = alert.popoverPresentationController {
            popOver.sourceView = navigationController.topViewController?.view
            popOver.sourceRect = sourceRect
        }

        navigationController.present(alert, animated: true)
    }

    /// Show a dialog with the badge's description. If the badge has been earned then the dialog has an option to share otherwise the progress is presented.
    func showBadgeDetails(_ badge: Badge) {
        if User.current.isBadgeEarned(badge) {
            let body = badge.description.fromSimpleHTML()
            showAlert(title: badge.name, body: body, alternateTitle: "Share") { [weak self] in
                self?.shareBadge(badge)
            }
        } else {
            let body = badge.description.centered() + User.current.badgeProgress(badge)
            showAlert(title: badge.name, body: body)
        }
    }

    /// Share a specific badge the user earned.
    func shareBadge(_ badge: Badge) {
        let image = badge.image.imageForSharing
        let text = "I earned the badge \(badge.name) in Unwrap by @twostraws. Download it here: \(Unwrap.appURL)"

        let alert = UIActivityViewController(activityItems: [text, image], applicationActivities: nil)

        // if we're on iPad there is nowhere sensible to anchor this from, so just center it
        if let popOver = alert.popoverPresentationController {
            popOver.sourceView = self.navigationController.view
            popOver.sourceRect = CGRect(x: self.navigationController.view.frame.midX, y: self.navigationController.view.frame.midY, width: 0, height: 0)
        }

        self.navigationController.present(alert, animated: true)
    }

    /// We need to catch them sharing their score successfully, because doing it at least once to Facebook or Twitter unlocks a badge.
    func handleScoreSharingResult(activityType: UIActivity.ActivityType?, completed: Bool, returnedItems: [Any]?, error: Error?) {
        guard completed == true else { return }

        if activityType == .postToFacebook || activityType == .postToTwitter {
            User.current.sharedScore()
        }
    }

    /// HTTP(S) URLs should be opened internally, but all others – e.g. mailto: – should be opened by the system.
    func open(_ url: URL) {
        if url.scheme?.hasPrefix("http") == true {
            // we'll open web URLs inside the app
            let viewController = WebViewController(url: url)
            navigationController.pushViewController(viewController, animated: true)
        } else {
            // send all other types of URL over to the main application to figure out
            UIApplication.shared.open(url)
        }
    }
}

import AVKit
import SwiftEntryKit
import UIKit

/// Управляет всем, что запускается с вкладки "Обучение" в приложении.
class LearnCoordinator: Coordinator, Awarding, Skippable, AlertHandling, AnswerHandling, UISplitViewControllerDelegate {
    var splitViewController = UISplitViewController()
    var primaryNavigationController = CoordinatedNavigationController()
    var activeStudyReview: StudyReview!

    /// Может ли пользователь иметь несколько попыток задать вопросы или нет
    let retriesAllowed = true

    init() {
        // Настройка главного контроллера просмотра
        primaryNavigationController.navigationBar.prefersLargeTitles = true
        primaryNavigationController.coordinator = self

        let viewController = LearnViewController(style: .plain)
        viewController.coordinator = self
        primaryNavigationController.viewControllers = [viewController]

        // Настройка контроллера подробного просмотра
        let detailViewController = PleaseSelectViewController.instantiate()
        detailViewController.selectionMode = .learn

        splitViewController.viewControllers = [primaryNavigationController, detailViewController]
        splitViewController.tabBarItem = UITabBarItem(title: "Learn", image: UIImage(bundleName: "Learn"), tag: 1)

        if #available(iOS 13, *) {
            if splitViewController.traitCollection.userInterfaceIdiom == .phone {
                // Без этого обходного решения за контроллерами push-просмотра появляется неприятный цвет, только в темном режиме на iOS 13.
                splitViewController.view.backgroundColor = .systemBackground
            }
        }

        // заставьте этот контроллер разделенного просмотра вести себя разумно на iPad
        splitViewController.preferredDisplayMode = .allVisible
        splitViewController.delegate = SplitViewControllerDelegate.shared
    }

    /// Показывает список распространенных терминов Swift
    func showGlossary() {
        let vc = GlossaryViewController(style: .plain)
        primaryNavigationController.pushViewController(vc, animated: true)
    }

    /// Запускается, когда у нас уже есть настроенный и готовый к работе контроллер просмотра исследования, поэтому мы просто показываем его.
    func startStudying(using viewController: UIViewController) {
        let detailNav = CoordinatedNavigationController(rootViewController: viewController)
        splitViewController.showDetailViewController(detailNav, sender: self)
    }

    /// Создает и настраивает – но не показывает! – контроллер просмотра исследования для конкретной главы. Это может быть вызвано, когда пользователь нажимает на главу или когда он касается ее в 3D.
    func studyViewController(for title: String) -> StudyViewController {
        activeStudyReview = StudyReview.review(for: title.bundleName)

        let studyViewController = StudyViewController()
        studyViewController.hidesBottomBarWhenPushed = true
        studyViewController.title = title
        studyViewController.chapter = title.bundleName
        studyViewController.coordinator = self

        return studyViewController
    }

    /// Создает, настраивает и представляет контроллер просмотра исследования для конкретной главы.
    func startStudying(title: String) {
        let viewController = studyViewController(for: title)
        startStudying(using: viewController)
    }
    
    /// Отображает полноэкранный видеоплеер, когда пользователь нажимает на изображение в верхней части контроллера study view.
    func playStudyVideo() {
        guard let videoURL = Bundle.main.url(forResource: activeStudyReview.title.bundleName, withExtension: "mp4") else { return }
        let player = AVPlayer(url: videoURL)

        // Было бы неплохо создать пользовательский подкласс
        // AVPlayerViewController, который всегда является ландшафтным,
        // но это приводит к тому, что наше положение прокрутки текстового представления меняется
        // спрыгнуть вниз по какой-то причине. Ура.
        let playerViewController = AVPlayerViewController()
        playerViewController.player = player
        player.play()

        splitViewController.present(playerViewController, animated: true)
    }

    /// Когда мы закончим изучение, мы либо перейдем к постскриптуму, либо приступим к рецензированию.
    @objc func finishedStudying() {
        if activeStudyReview.postscript.isEmpty {
            beginReview()
        } else {
            showPostscript()
        }
    }

    /// Показывает правильный экран просмотра текущей главы.
    func beginReview() {
        assert(activeStudyReview.reviewType == "multipleSelection" || activeStudyReview.reviewType == "singleSelection", "Unknown review type for study review: \(activeStudyReview.reviewType).")

        if activeStudyReview.reviewType == "multipleSelection" {
            let viewController = MultipleSelectReviewViewController.instantiate()
            viewController.review = activeStudyReview
            viewController.sectionName = activeStudyReview.title.bundleName
            viewController.coordinator = self

            let detailNav = CoordinatedNavigationController(rootViewController: viewController)
            splitViewController.showDetailViewController(detailNav, sender: self)
        } else {
            let viewController = SingleSelectReviewViewController.instantiate()
            viewController.review = activeStudyReview
            viewController.coordinator = self

            let detailNav = CoordinatedNavigationController(rootViewController: viewController)
            splitViewController.showDetailViewController(detailNav, sender: self)
        }
    }

    /// Показывает короткое сообщение после того, как пользователь закончил чтение главы, но до начала просмотра.
    func showPostscript() {
        assert(activeStudyReview.postscript.isEmpty == false, "Attempting to show empty post script.")

        let alert = AlertViewController.instantiate()
        alert.coordinator = self
        alert.title = activeStudyReview.title
        alert.alertType = .postscript
        alert.body = activeStudyReview.postscript.fromSimpleHTML()
        alert.presentAsAlert()
    }

    /// Это будет вызвано, когда постскриптум будет отклонен, так что мы можем перейти к просмотру.
    func alertDismissed(type: AlertType) {
        SwiftEntryKit.dismiss {
            if type == .postscript {
                self.beginReview()
            }
        }
    }

    /// Это вызывается, когда пользователь отправил ответ контроллеру просмотра отзывов. Если это контроллер вида с одним выделением, то мы либо заканчиваем просмотр, либо показываем другой контроллер вида с одним выделением; если это контроллер вида с несколькими выделениями, то мы заканчиваем просмотр, потому что это только один экран.
    func answerSubmitted(from reviewViewController: UIViewController, wasCorrect: Bool) {
        if let single = reviewViewController as? SingleSelectReviewViewController {
            if single.questionNumber == 8 {
                // Это обзор одиночного отбора, и это последний вопрос, так что мы закончили обзор.
                finishedReviewing()
            } else {
                // Это обзор одной подборки, но мы еще не показали их все, поэтому покажите еще одну по порядку.
                let viewController = SingleSelectReviewViewController.instantiate()
                viewController.review = single.review
                viewController.answers = single.answers
                viewController.questionNumber = single.questionNumber + 1
                viewController.coordinator = self

                reviewViewController.navigationController?.pushViewController(viewController, animated: true)
            }
        } else {
            /// это обзор с несколькими вариантами выбора, поэтому мы показываем только один – мы закончили просмотр.
            finishedReviewing()
        }
    }

    /// Вызывается, когда пользователь не хочет продолжать просмотр этой главы, поэтому мы либо начисляем баллы, либо выходим из игры.
    func skipReviewing() {
        let sectionName = activeStudyReview.title.bundleName

        if User.current.hasLearned(sectionName) {
            // Вернитесь к основному списку глав.
            award(points: 0, for: .review(chapter: sectionName))
        } else {
            // Они должны получить баллы, по крайней мере, за прочтение главы, поэтому покажите экран награждения.
            award(points: User.pointsForLearning, for: .learn(chapter: sectionName))
        }
    }
    
    /// Вызывается, когда пользователь завершает просмотр главы.
    func finishedReviewing() {
        let sectionName = activeStudyReview.title.bundleName

        if User.current.hasReviewed(sectionName) {
            // Они уже просмотрели эту главу, так что не начисляйте им больше баллов.
            award(points: 0, for: .review(chapter: sectionName))
        } else {
            // Они впервые просматривают эту главу, поэтому присудите им баллы.
            var pointsToAward = User.pointsForReviewing

            // если пользователь читает это в первый раз, мы также должны начислить ему бонусные баллы за прочтение
            if !User.current.hasLearned(sectionName) {
                pointsToAward += User.pointsForLearning
            }

            award(points: pointsToAward, for: .review(chapter: sectionName))
        }
    }

    // Отдельные избранные отзывы делятся на группы по восемь человек.
    func titleSuffix(for item: Sequenced) -> String {
        return " (\(item.questionNumber)/8)"
    }

    func show(url: URL) {
        let viewController = WebViewController(url: url)
        let detailNav = CoordinatedNavigationController(rootViewController: viewController)
        splitViewController.showDetailViewController(detailNav, sender: self)
    }
}
